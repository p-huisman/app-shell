try{self["workbox:core:7.2.0"]&&_()}catch{}var M=(o,...e)=>{let t=o;return e.length>0&&(t+=` :: ${JSON.stringify(e)}`),t};var S=M;var c=class extends Error{constructor(e,t){let r=S(e,t);super(r),this.name=e,this.details=t}};try{self["workbox:routing:7.2.0"]&&_()}catch{}var v="GET";var f=o=>o&&typeof o=="object"?o:{handle:o};var p=class{constructor(e,t,r=v){this.handler=f(t),this.match=e,this.method=r}setCatchHandler(e){this.catchHandler=f(e)}};var y=class extends p{constructor(e,t,r){let n=({url:a})=>{let s=e.exec(a.href);if(s&&!(a.origin!==location.origin&&s.index!==0))return s.slice(1)};super(n,t,r)}};var O=o=>new URL(String(o),location.href).href.replace(new RegExp(`^${location.origin}`),"");var N=class{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{let{request:t}=e,r=this.handleRequest({request:t,event:e});r&&e.respondWith(r)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){let{payload:t}=e.data,r=Promise.all(t.urlsToCache.map(n=>{typeof n=="string"&&(n=[n]);let a=new Request(...n);return this.handleRequest({request:a,event:e})}));e.waitUntil(r),e.ports&&e.ports[0]&&r.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:t}){let r=new URL(e.url,location.href);if(!r.protocol.startsWith("http"))return;let n=r.origin===location.origin,{params:a,route:s}=this.findMatchingRoute({event:t,request:e,sameOrigin:n,url:r}),i=s&&s.handler,u=[],g=e.method;if(!i&&this._defaultHandlerMap.has(g)&&(i=this._defaultHandlerMap.get(g)),!i)return;let m;try{m=i.handle({url:r,request:e,event:t,params:a})}catch(w){m=Promise.reject(w)}let l=s&&s.catchHandler;return m instanceof Promise&&(this._catchHandler||l)&&(m=m.catch(async w=>{if(l)try{return await l.handle({url:r,request:e,event:t,params:a})}catch(q){q instanceof Error&&(w=q)}if(this._catchHandler)return this._catchHandler.handle({url:r,request:e,event:t});throw w})),m}findMatchingRoute({url:e,sameOrigin:t,request:r,event:n}){let a=this._routes.get(r.method)||[];for(let s of a){let i,u=s.match({url:e,sameOrigin:t,request:r,event:n});if(u)return i=u,(Array.isArray(i)&&i.length===0||u.constructor===Object&&Object.keys(u).length===0||typeof u=="boolean")&&(i=void 0),{route:s,params:i}}return{}}setDefaultHandler(e,t=v){this._defaultHandlerMap.set(t,f(e))}setCatchHandler(e){this._catchHandler=f(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new c("unregister-route-but-not-found-with-method",{method:e.method});let t=this._routes.get(e.method).indexOf(e);if(t>-1)this._routes.get(e.method).splice(t,1);else throw new c("unregister-route-route-not-registered")}};var E,x=()=>(E||(E=new N,E.addFetchListener(),E.addCacheListener()),E);function C(o,e,t){let r;if(typeof o=="string"){let a=new URL(o,location.href),s=({url:i})=>i.href===a.href;r=new p(s,e,t)}else if(o instanceof RegExp)r=new y(o,e,t);else if(typeof o=="function")r=new p(o,e,t);else if(o instanceof p)r=o;else throw new c("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return x().registerRoute(r),r}var h={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration<"u"?registration.scope:""},T=o=>[h.prefix,o,h.suffix].filter(e=>e&&e.length>0).join("-"),W=o=>{for(let e of Object.keys(h))o(e)},V={updateDetails:o=>{W(e=>{typeof o[e]=="string"&&(h[e]=o[e])})},getGoogleAnalyticsName:o=>o||T(h.googleAnalytics),getPrecacheName:o=>o||T(h.precache),getPrefix:()=>h.prefix,getRuntimeName:o=>o||T(h.runtime),getSuffix:()=>h.suffix};function P(o,e){let t=new URL(o);for(let r of e)t.searchParams.delete(r);return t.href}async function L(o,e,t,r){let n=P(e.url,t);if(e.url===n)return o.match(e,r);let a=Object.assign(Object.assign({},r),{ignoreSearch:!0}),s=await o.keys(e,a);for(let i of s){let u=P(i.url,t);if(n===u)return o.match(i,r)}}var k=class{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}};var A=new Set;async function F(){for(let o of A)await o()}function D(o){return new Promise(e=>setTimeout(e,o))}try{self["workbox:strategies:7.2.0"]&&_()}catch{}function $(o){return typeof o=="string"?new Request(o):o}var b=class{constructor(e,t){this._cacheKeys={},Object.assign(this,t),this.event=t.event,this._strategy=e,this._handlerDeferred=new k,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(let r of this._plugins)this._pluginStateMap.set(r,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(e){let{event:t}=this,r=$(e);if(r.mode==="navigate"&&t instanceof FetchEvent&&t.preloadResponse){let s=await t.preloadResponse;if(s)return s}let n=this.hasCallback("fetchDidFail")?r.clone():null;try{for(let s of this.iterateCallbacks("requestWillFetch"))r=await s({request:r.clone(),event:t})}catch(s){if(s instanceof Error)throw new c("plugin-error-request-will-fetch",{thrownErrorMessage:s.message})}let a=r.clone();try{let s;s=await fetch(r,r.mode==="navigate"?void 0:this._strategy.fetchOptions);for(let i of this.iterateCallbacks("fetchDidSucceed"))s=await i({event:t,request:a,response:s});return s}catch(s){throw n&&await this.runCallbacks("fetchDidFail",{error:s,event:t,originalRequest:n.clone(),request:a.clone()}),s}}async fetchAndCachePut(e){let t=await this.fetch(e),r=t.clone();return this.waitUntil(this.cachePut(e,r)),t}async cacheMatch(e){let t=$(e),r,{cacheName:n,matchOptions:a}=this._strategy,s=await this.getCacheKey(t,"read"),i=Object.assign(Object.assign({},a),{cacheName:n});r=await caches.match(s,i);for(let u of this.iterateCallbacks("cachedResponseWillBeUsed"))r=await u({cacheName:n,matchOptions:a,cachedResponse:r,request:s,event:this.event})||void 0;return r}async cachePut(e,t){let r=$(e);await D(0);let n=await this.getCacheKey(r,"write");if(!t)throw new c("cache-put-with-no-response",{url:O(n.url)});let a=await this._ensureResponseSafeToCache(t);if(!a)return!1;let{cacheName:s,matchOptions:i}=this._strategy,u=await self.caches.open(s),g=this.hasCallback("cacheDidUpdate"),m=g?await L(u,n.clone(),["__WB_REVISION__"],i):null;try{await u.put(n,g?a.clone():a)}catch(l){if(l instanceof Error)throw l.name==="QuotaExceededError"&&await F(),l}for(let l of this.iterateCallbacks("cacheDidUpdate"))await l({cacheName:s,oldResponse:m,newResponse:a.clone(),request:n,event:this.event});return!0}async getCacheKey(e,t){let r=`${e.url} | ${t}`;if(!this._cacheKeys[r]){let n=e;for(let a of this.iterateCallbacks("cacheKeyWillBeUsed"))n=$(await a({mode:t,request:n,event:this.event,params:this.params}));this._cacheKeys[r]=n}return this._cacheKeys[r]}hasCallback(e){for(let t of this._strategy.plugins)if(e in t)return!0;return!1}async runCallbacks(e,t){for(let r of this.iterateCallbacks(e))await r(t)}*iterateCallbacks(e){for(let t of this._strategy.plugins)if(typeof t[e]=="function"){let r=this._pluginStateMap.get(t);yield a=>{let s=Object.assign(Object.assign({},a),{state:r});return t[e](s)}}}waitUntil(e){return this._extendLifetimePromises.push(e),e}async doneWaiting(){let e;for(;e=this._extendLifetimePromises.shift();)await e}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(e){let t=e,r=!1;for(let n of this.iterateCallbacks("cacheWillUpdate"))if(t=await n({request:this.request,response:t,event:this.event})||void 0,r=!0,!t)break;return r||t&&t.status!==200&&(t=void 0),t}};var d=class{constructor(e={}){this.cacheName=V.getRuntimeName(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){let[t]=this.handleAll(e);return t}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});let t=e.event,r=typeof e.request=="string"?new Request(e.request):e.request,n="params"in e?e.params:void 0,a=new b(this,{event:t,request:r,params:n}),s=this._getResponse(a,r,t),i=this._awaitComplete(s,a,r,t);return[s,i]}async _getResponse(e,t,r){await e.runCallbacks("handlerWillStart",{event:r,request:t});let n;try{if(n=await this._handle(t,e),!n||n.type==="error")throw new c("no-response",{url:t.url})}catch(a){if(a instanceof Error){for(let s of e.iterateCallbacks("handlerDidError"))if(n=await s({error:a,event:r,request:t}),n)break}if(!n)throw a}for(let a of e.iterateCallbacks("handlerWillRespond"))n=await a({event:r,request:t,response:n});return n}async _awaitComplete(e,t,r,n){let a,s;try{a=await e}catch{}try{await t.runCallbacks("handlerDidRespond",{event:n,request:r,response:a}),await t.doneWaiting()}catch(i){i instanceof Error&&(s=i)}if(await t.runCallbacks("handlerDidComplete",{event:n,request:r,response:a,error:s}),t.destroy(),s)throw s}};var U={cacheWillUpdate:async({response:o})=>o.status===200||o.status===0?o:null};var R=class extends d{constructor(e={}){super(e),this.plugins.some(t=>"cacheWillUpdate"in t)||this.plugins.unshift(U)}async _handle(e,t){let r=[],n=t.fetchAndCachePut(e).catch(()=>{});t.waitUntil(n);let a=await t.cacheMatch(e),s;if(!a)try{a=await n}catch(i){i instanceof Error&&(s=i)}if(!a)throw new c("no-response",{url:e.url,error:s});return a}};C(o=>o.url.hostname.match("esm.sh"),new R);
